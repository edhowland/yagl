# this is the main processing loop
script :process_templates do
  require "erubis"
  require "event-engine"
  
  module FileInterest
    def interested? event
      event.respond_to? :file? and event.file?
    end
  end

  module Splitter
    include AlwaysInterested
    def handle event
      evt_parts = event.parts
      evt_parts.shift
      dpath = Pathname.new 'dest'
      [:noop, event, dpath.join(*evt_parts), {}]
    end
  end

  module Skipper
    include AlwaysInterested
    def handle event
      event[-1][:noop] = true if event[-2].exist?
      event
    end
  end

  module TranslatprCommand
    def translate(src, dest, opts={})
      unless opts[:noop]
        qputs "Translate #{src.to_s} to #{dest.to_s}"
        eruby = Erubis::Eruby.new(File.read(src))    # create Eruby object
        # FIXME - remove once running in real binding
        target = Pathname.pwd.basename
        result = eruby.result(binding())
        File.open(dest, 'w+') do |f|
          f.write(result)
        end
      end
    end
  end
  
  module Noop
    def noop(*args); end
  end

  module Translator
    include FileInterest
    alias :file_interested? :interested?
    def interested? event
      file_interested?(event) and event.final_ext =~ %r{eruby|erb} 
    end
    def handle event
      dest = event[-2]
      target_fname = dest.strip_final_ext
      dparts = dest.parts
      dparts[-1] = target_fname
      dest = Pathname.new('.').join(*dparts)
      event[0] = :translate
      event[-2] = dest
      event
    end
  end

  module DirectoryMaker
    def interested? event
      event.respond_to? :directory? and event.directory?
    end
    def handle event
      event.shift # get rid of :noop, shift to the left
      event[0] = :mkdir_p
      event
    end
  end

  module FileCopier
    include FileInterest
    def handle event
      event[0] = :cp
      event[-1][:preserve] = true
      event
    end
  end

  module Action
    include AlwaysInterested
    def handle event
      puts "#{(event[-1][:noop] || (event[-2].exist? && event[-2].directory?)) ? 'Exists' : 'Create'} #{event[-2].to_s}"
      event
    end
  end

  module ExecCommand
    include AlwaysInterested
    include FileUtils
    include Noop
    include TranslatprCommand
    def handle event
      self.send event[0], *event[(1..-1)]
      event
    end
  end
  
  module Debugger
    include AlwaysInterested
    def handle event
      puts event.inspect
      event
    end
  end
  
  engine = EventEngine::Engine.new
  engine.setup do |en|
    en.handle Splitter
    en.handle DirectoryMaker
    en.handle FileCopier
    en.handle Translator
    en.handle Skipper if skip? or !force?
    en.handle Debugger if debug?
    en.handle Action unless quiet? and !verbose?
    en.handle ExecCommand unless pretend?
  end

  templated = Dir[template_root + '/**/*'].map {|l| Pathname.new l}

  templated.each {|l| engine.trigger l}
  vputs 'Done'
end
